struct OurVertexShaderOutput {
@location(0) color: vec4f,
@builtin(position) position: vec4f,
};

@group(0) @binding(0) var<storage, read> data: array<f32>;
@group(0) @binding(1) var<storage, read> keys: array<i32>;
@group(0) @binding(2) var<uniform> projectionMatrix: mat4x4f;
@vertex fn vs(
@builtin(vertex_index) vertexIndex : u32
) -> OurVertexShaderOutput {

var vsOutput: OurVertexShaderOutput;

var a = projectionMatrix;
var key = keys[vertexIndex];
var index = u32(key >> 12);
var position = vec4f(data[index*20],data[index*20+1],data[index*20+2],1);
position = projectionMatrix * position;
vsOutput.position = position;
vsOutput.color = vec4f(data[index*20+6],data[index*20+7],data[index*20+8],data[index*20+9]);
return vsOutput;
}





@fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {

var alpha = fsInput.color.a * exp(-0.5 * 0.8);
var tex1 = vec4(fsInput.color.rgb * alpha, alpha);

return (tex1);


}