struct OurVertexShaderOutput {
@location(0) color: vec4f,
@builtin(position) position: vec4f,
@location(1) @interpolate(linear) TexCoord: vec2<f32>,
};

struct MyVSInput {
    @location(0) key: i32,
};

@group(0) @binding(0) var<storage, read> data: array<f32>;
@group(0) @binding(2) var<uniform> projectionMatrix: mat4x4f;
@group(0) @binding(1) var<uniform> cameraMatrix: mat3x3f;
@group(0) @binding(3) var<uniform> camPos: vec3f;
@vertex fn vs(
v: MyVSInput,
@builtin(vertex_index) vertexIndex : u32
) -> OurVertexShaderOutput {
let quads = array(
    vec2f(-0.1, -0.1),
    vec2f(0.1, -0.1),
    vec2f(-0.1, 0.1),
    vec2f(-0.1, 0.1),
    vec2f(0.1, -0.1),
    vec2f(0.1, 0.1),
);
var vsOutput: OurVertexShaderOutput;

let a = cameraMatrix;
let b = camPos;
var index = u32(v.key >> 12);
var worldPosition = vec4f(data[index*20],data[index*20+1],data[index*20+2],1);
var position = projectionMatrix * worldPosition;

/*
let scale = vec3f(data[index*20+10],data[index*20+11],data[index*20+12]);
let rot = vec4f(data[index*20+13],data[index*20+14],data[index*20+15],data[index*20+16]);
let M = projectedContourOfEllipsoid(scale, rot, worldPosition.xyz);
let translation = extractTranslationOfEllipse(M);
let rotation = extractRotationOfEllipse(M);
var semi_axes = extractScaleOfEllipse(M, translation, rotation);
var transformation = mat3x2<f32>(
    vec2<f32>(rotation.y, -rotation.x) * (semi_axes.x*0.2),
    vec2<f32>(rotation.x, rotation.y) * (semi_axes.y*0.2),
    translation,
);

/*
let inverse = mat2x2<f32>(
            transformation[1][1], -transformation[0][1],
            -transformation[1][0], transformation[0][0],
        ) * (1.0 / (transformation[0][0] * transformation[1][1] - transformation[0][1] * transformation[1][0]));
let radius = sqrt(max(dot(transformation[0], transformation[0]), dot(transformation[1], transformation[1])));



vsOutput.TexCoord = quads[vertexIndex]*2*radius;
vsOutput.position = vec4<f32>((transformation[2] + vsOutput.TexCoord)/vec2f(0.7,0.7),0.0,1.0);
vsOutput.TexCoord = inverse * vsOutput.TexCoord;
*/

let T = mat3x3(
    vec3<f32>(transformation[0], 0.0),
    vec3<f32>(transformation[1], 0.0),
    vec3<f32>(transformation[2], 1.0),
);
vsOutput.TexCoord = quads[vertexIndex] * 2;
vsOutput.position = vec4<f32>((T * vec3<f32>(vsOutput.TexCoord, 1.0)).xy / vec2f(0.7,0.7), 0.0, 1.0);
*/
vsOutput.position = position + vec4f(quads[vertexIndex],0,0);
vsOutput.TexCoord = quads[vertexIndex]*2;



vsOutput.color = vec4f(data[index*20+6],data[index*20+7],data[index*20+8],data[index*20+9]);
return vsOutput;
}





@fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {
let power = dot(fsInput.TexCoord, fsInput.TexCoord);
var alpha = fsInput.color.a * exp(-0.8 * power);
//var alpha = fsInput.color.a;
if(alpha < 1/255){
    discard;
}
var tex1 = vec4<f32>(fsInput.color.rgb * alpha, alpha);

return (tex1);


}





fn extractTranslationOfEllipse(M: mat3x3<f32>) -> vec2<f32> {
    /*
        The center of the ellipse is at the extremum (minimum / maximum) of the implicit curve.
        So, take the partial derivative in x and y, which is: (2.0 * M.x.x * x + M.x.y * y + M.x.z, M.x.y * x + 2.0 * M.y.y * y + M.y.z)
        And the roots of that partial derivative are the position of the extremum, thus the translation of the ellipse.
    */
    let discriminant = M[0][0] * M[1][1] - M[0][1] * M[0][1];
    let inverse_discriminant = 1.0 / discriminant;
    return vec2<f32>(
        M[0][1] * M[1][2] - M[1][1] * M[0][2],
        M[0][1] * M[0][2] - M[0][0] * M[1][2],
    ) * inverse_discriminant;
}

fn extractRotationOfEllipse(M: mat3x3<f32>) -> vec2<f32> {
    /*
        phi = atan(2.0 * M[0][1] / (M[0][0] - M[1][1])) / 2
        k = cos(phi)
        j = sin(phi)
        Insert angle phi into cos() and then apply the half-angle identity to get:
    */
    let a = (M[0][0] - M[1][1]) * (M[0][0] - M[1][1]);
    let b = a + 4.0 * M[0][1] * M[0][1];
    let c = 0.5 * sqrt(a / b);
    var j = sqrt(0.5 - c);
    var k = -sqrt(0.5 + c) * sign(M[0][1]) * sign(M[0][0] - M[1][1]);
    if(M[0][1] < 0.0 || M[0][0] - M[1][1] < 0.0) {
        k = -k;
        j = -j;
    }
    if(M[0][0] - M[1][1] < 0.0) {
        let t = j;
        j = -k;
        k = t;
    }
    return vec2<f32>(j, k);
}

fn extractScaleOfEllipse(M: mat3x3<f32>, translation: vec2<f32>, rotation: vec2<f32>) -> vec2<f32> {
    /*b = sqrt(b);
    let q = (M[2][2] + (2.0 * M[0][1] * M[0][2] * M[1][2] - (M[0][0] * M[1][2] * M[1][2] + M[1][1] * M[0][2] * M[0][2])) * inverse_discriminant) * inverse_discriminant * 0.25;
    let focal_point_squared = 4.0 * abs(q) * b;
    let semi_major_axis_squared = (b - sign(q) * (M[0][0] + M[1][1])) * q * 2.0;
    let semi_major_axis = sqrt(semi_major_axis_squared);
    let semi_minor_axis = sqrt(semi_major_axis_squared - focal_point_squared);*/

    /*b = sqrt(b);
    let numerator = -2.0 * (M[0][0] * M[1][2] * M[1][2] + M[1][1] * M[0][2] * M[0][2] + M[2][2] * M[0][1] * M[0][1] - 2.0 * M[0][1] * M[0][2] * M[1][2] - M[0][0] * M[1][1] * M[2][2]);
    let semi_major_axis = sqrt(numerator / (discriminant * (-b - (M[0][0] + M[1][1]))));
    let semi_minor_axis = sqrt(numerator / (discriminant * (b - (M[0][0] + M[1][1]))));*/

    let d = 2.0 * M[0][1] * rotation.x * rotation.y;
    let e = M[2][2] - (M[0][0] * translation.x * translation.x + M[1][1] * translation.y * translation.y + 2.0 * M[0][1] * translation.x * translation.y);
    // let e = dot(sqrt_M.z, sqrt_M.z) - dot(sqrt_M.x * translation.x + sqrt_M.y * translation.y, sqrt_M.x * translation.x + sqrt_M.y * translation.y);
    let semi_major_axis = sqrt(abs(e / (M[0][0] * rotation.y * rotation.y + M[1][1] * rotation.x * rotation.x - d)));
    let semi_minor_axis = sqrt(abs(e / (M[0][0] * rotation.x * rotation.x + M[1][1] * rotation.y * rotation.y + d)));

    return vec2<f32>(semi_major_axis, semi_minor_axis);
}

fn projectedContourOfEllipsoid(scale: vec3<f32>, rotation: vec4<f32>, translation: vec3<f32>) -> mat3x3<f32> {
    var transform: mat3x3<f32> = quatToMat(rotation);
    transform[0] /= scale.x;
    transform[1] /= scale.y;
    transform[2] /= scale.z;
    let ray_origin = camPos - translation;
    let local_ray_origin = transform * ray_origin;
    let local_ray_origin_squared = local_ray_origin * local_ray_origin;

    // Calculate the bounding cone of the ellipsoid with its vertex at the camera position
    let diagonal = 1.0 - local_ray_origin_squared.yxx - local_ray_origin_squared.zzy;
    let triangle = local_ray_origin.yxx * local_ray_origin.zzy;
    let A = mat3x3<f32>(
        diagonal.x, triangle.z, triangle.y,
        triangle.z, diagonal.y, triangle.x,
        triangle.y, triangle.x, diagonal.z,
    );

    transform = transpose(cameraMatrix) * transform;
    let M = transform * A * transpose(transform);

    // Again, M is sufficient to render the ellipse: dot(pos_in_view_plane, M * pos_in_view_plane) = 0
    return M;
}

fn quatToMat(p: vec4<f32>) -> mat3x3<f32> {
  var q = p * sqrt(2.0);
  var yy = q.y * q.y;
  var yz = q.y * q.z;
  var yw = q.y * q.w;
  var yx = q.y * q.x;
  var zz = q.z * q.z;
  var zw = q.z * q.w;
  var zx = q.z * q.x;
  var ww = q.w * q.w;
  var wx = q.w * q.x;
  return mat3x3<f32>(
    1.0 - zz - ww, yz + wx, yw - zx,
    yz - wx, 1.0 - yy - ww, zw + yx,
    yw + zx, zw - yx, 1.0 - yy - zz,
  );
}