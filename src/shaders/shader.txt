struct OurVertexShaderOutput {
@location(0) color: vec4f,
@builtin(position) position: vec4f,
@location(1) @interpolate(linear) TexCoord: vec2<f32>,
@location(2) cov1: vec3f,
@location(3) cov2: vec3f,
@location(4) cov3: vec3f,
};

struct MyVSInput {
    @location(0) key: i32,
};

@group(0) @binding(0) var<storage, read> data: array<f32>;
@group(0) @binding(2) var<uniform> projectionMatrix: mat4x4f;
@group(0) @binding(1) var<uniform> cameraMatrix: mat3x3f;
@group(0) @binding(3) var<uniform> camPos: vec3f;
@group(0) @binding(4) var<uniform> viewMatrix: mat4x4f;
@group(0) @binding(5) var<storage, read> keys: array<i32>;
@vertex fn vs(
v: MyVSInput,
@builtin(vertex_index) vertexIndex : u32
) -> OurVertexShaderOutput {
let quads = array(
    vec2f(-1, -1),
    vec2f(1, -1),
    vec2f(-1, 1),
    vec2f(-1, 1),
    vec2f(1, -1),
    vec2f(1, 1),
);
var vsOutput: OurVertexShaderOutput;

let a = cameraMatrix;
let b = camPos;
let c = projectionMatrix;
let d = viewMatrix;
let e = keys[0];
var index = u32(v.key >> 12);
var worldPosition = vec4f(data[index*20],data[index*20+1],data[index*20+2],1);
var position = projectionMatrix * worldPosition;
var covar = mat4x4f(data[index*20+10],data[index*20+11],data[index*20+12],0,data[index*20+13],data[index*20+14],data[index*20+15],0,data[index*20+16],data[index*20+17],data[index*20+18],0,0,0,0,1);
covar = projectionMatrix * viewMatrix * covar * transpose(viewMatrix) * transpose(projectionMatrix);
vsOutput.cov1 = covar[0].xyz;
vsOutput.cov2 = covar[1].xyz;
vsOutput.cov3 = covar[2].xyz;

vsOutput.position = position + vec4f(quads[vertexIndex]*2,0,0);
vsOutput.TexCoord = quads[vertexIndex]*2;



vsOutput.color = vec4f(data[index*20+6],data[index*20+7],data[index*20+8],data[index*20+9]*0.01);
return vsOutput;
}





@fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {
var totAlpha: f32 = 0;
var c = vec4f(0,0,0,0);
for(var i: u32 = 0; i < 64; i++) {
    if(totAlpha > 0.99f){
        return (c);
    }
    var index = u32(keys[i] >> 12);
    var worldPosition = vec4f(data[index*20],data[index*20+1],data[index*20+2],1);
    var position = projectionMatrix * worldPosition;
    var covar = mat4x4f(data[index*20+10],data[index*20+11],data[index*20+12],0,data[index*20+13],data[index*20+14],data[index*20+15],0,data[index*20+16],data[index*20+17],data[index*20+18],0,0,0,0,1);
    covar = projectionMatrix * viewMatrix * covar * transpose(viewMatrix) * transpose(projectionMatrix);
    let color = vec4f(data[index*20+6],data[index*20+7],data[index*20+8],data[index*20+9]);


    let covar2 = mat2x2f(fsInput.cov1.xy,fsInput.cov2.xy);
    let power = dot(position*covar,position);
    var alpha = color.a * exp(-0.5 * 1);

    if(alpha < 1/255){
        discard;
    }

    totAlpha += alpha;
    c += vec4f(color.rgb * alpha, alpha);

}

return (c);


}





fn extractTranslationOfEllipse(M: mat3x3<f32>) -> vec2<f32> {
    /*
        The center of the ellipse is at the extremum (minimum / maximum) of the implicit curve.
        So, take the partial derivative in x and y, which is: (2.0 * M.x.x * x + M.x.y * y + M.x.z, M.x.y * x + 2.0 * M.y.y * y + M.y.z)
        And the roots of that partial derivative are the position of the extremum, thus the translation of the ellipse.
    */
    let discriminant = M[0][0] * M[1][1] - M[0][1] * M[0][1];
    let inverse_discriminant = 1.0 / discriminant;
    return vec2<f32>(
        M[0][1] * M[1][2] - M[1][1] * M[0][2],
        M[0][1] * M[0][2] - M[0][0] * M[1][2],
    ) * inverse_discriminant;
}

fn extractRotationOfEllipse(M: mat3x3<f32>) -> vec2<f32> {
    /*
        phi = atan(2.0 * M[0][1] / (M[0][0] - M[1][1])) / 2
        k = cos(phi)
        j = sin(phi)
        Insert angle phi into cos() and then apply the half-angle identity to get:
    */
    let a = (M[0][0] - M[1][1]) * (M[0][0] - M[1][1]);
    let b = a + 4.0 * M[0][1] * M[0][1];
    let c = 0.5 * sqrt(a / b);
    var j = sqrt(0.5 - c);
    var k = -sqrt(0.5 + c) * sign(M[0][1]) * sign(M[0][0] - M[1][1]);
    if(M[0][1] < 0.0 || M[0][0] - M[1][1] < 0.0) {
        k = -k;
        j = -j;
    }
    if(M[0][0] - M[1][1] < 0.0) {
        let t = j;
        j = -k;
        k = t;
    }
    return vec2<f32>(j, k);
}

fn extractScaleOfEllipse(M: mat3x3<f32>, translation: vec2<f32>, rotation: vec2<f32>) -> vec2<f32> {
    /*b = sqrt(b);
    let q = (M[2][2] + (2.0 * M[0][1] * M[0][2] * M[1][2] - (M[0][0] * M[1][2] * M[1][2] + M[1][1] * M[0][2] * M[0][2])) * inverse_discriminant) * inverse_discriminant * 0.25;
    let focal_point_squared = 4.0 * abs(q) * b;
    let semi_major_axis_squared = (b - sign(q) * (M[0][0] + M[1][1])) * q * 2.0;
    let semi_major_axis = sqrt(semi_major_axis_squared);
    let semi_minor_axis = sqrt(semi_major_axis_squared - focal_point_squared);*/

    /*b = sqrt(b);
    let numerator = -2.0 * (M[0][0] * M[1][2] * M[1][2] + M[1][1] * M[0][2] * M[0][2] + M[2][2] * M[0][1] * M[0][1] - 2.0 * M[0][1] * M[0][2] * M[1][2] - M[0][0] * M[1][1] * M[2][2]);
    let semi_major_axis = sqrt(numerator / (discriminant * (-b - (M[0][0] + M[1][1]))));
    let semi_minor_axis = sqrt(numerator / (discriminant * (b - (M[0][0] + M[1][1]))));*/

    let d = 2.0 * M[0][1] * rotation.x * rotation.y;
    let e = M[2][2] - (M[0][0] * translation.x * translation.x + M[1][1] * translation.y * translation.y + 2.0 * M[0][1] * translation.x * translation.y);
    // let e = dot(sqrt_M.z, sqrt_M.z) - dot(sqrt_M.x * translation.x + sqrt_M.y * translation.y, sqrt_M.x * translation.x + sqrt_M.y * translation.y);
    let semi_major_axis = sqrt(abs(e / (M[0][0] * rotation.y * rotation.y + M[1][1] * rotation.x * rotation.x - d)));
    let semi_minor_axis = sqrt(abs(e / (M[0][0] * rotation.x * rotation.x + M[1][1] * rotation.y * rotation.y + d)));

    return vec2<f32>(semi_major_axis, semi_minor_axis);
}

fn projectedContourOfEllipsoid(scale: vec3<f32>, rotation: vec4<f32>, translation: vec3<f32>) -> mat3x3<f32> {
    var transform: mat3x3<f32> = quatToMat(rotation);
    transform[0] /= scale.x;
    transform[1] /= scale.y;
    transform[2] /= scale.z;
    let ray_origin = camPos - translation;
    let local_ray_origin = transform * ray_origin;
    let local_ray_origin_squared = local_ray_origin * local_ray_origin;

    // Calculate the bounding cone of the ellipsoid with its vertex at the camera position
    let diagonal = 1.0 - local_ray_origin_squared.yxx - local_ray_origin_squared.zzy;
    let triangle = local_ray_origin.yxx * local_ray_origin.zzy;
    let A = mat3x3<f32>(
        diagonal.x, triangle.z, triangle.y,
        triangle.z, diagonal.y, triangle.x,
        triangle.y, triangle.x, diagonal.z,
    );

    transform = transpose(cameraMatrix) * transform;
    let M = transform * A * transpose(transform);

    // Again, M is sufficient to render the ellipse: dot(pos_in_view_plane, M * pos_in_view_plane) = 0
    return M;
}

fn quatToMat(p: vec4<f32>) -> mat3x3<f32> {
  var q = p * sqrt(2.0);
  var yy = q.y * q.y;
  var yz = q.y * q.z;
  var yw = q.y * q.w;
  var yx = q.y * q.x;
  var zz = q.z * q.z;
  var zw = q.z * q.w;
  var zx = q.z * q.x;
  var ww = q.w * q.w;
  var wx = q.w * q.x;
  return mat3x3<f32>(
    1.0 - zz - ww, yz + wx, yw - zx,
    yz - wx, 1.0 - yy - ww, zw + yx,
    yw + zx, zw - yx, 1.0 - yy - zz,
  );
}